<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bibi Runner</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      height: 100%;
      width: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    canvas {
      image-rendering: pixelated;
      width: 60vw;
      height: auto;
      max-height: 80vh;
      background: black;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="300"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Load images
const images = {
  rex_idle: loadImage('rex_idle.png'),
  rex_walk1: loadImage('rex_walk1.png'),
  rex_jump: loadImage('rex_jump.png'),
  obstacle1: loadImage('obstacle_tombstone.png'),
  obstacle2: loadImage('obstacle_crashed_missile.png'),
  obstacle3: loadImage('obstacle_flag_helmet.png'),
  obstacle4: loadImage('obstacle_flying_rocket.png'),
  bg: loadImage('background_telaviv.png')
};

function loadImage(src) {
  const img = new Image();
  img.src = src;
  return img;
}

// Load sounds (will be initialized after first interaction)
let jumpSounds = [];
let jumpSoundIndex = 0;
let backgroundMusic;
let audioInitialized = false;

// Constants
const groundY = 280;
const entitySize = 100;
const backgroundYOffset = 30;
const gravity = 0.75;
const jumpPower = -18;

// Game state
let rex, obstacles, backgroundX, gameOver, obstacleTimer, lastTimestamp, gameOverTime;

function resetGame() {
  rex = {
    x: 100,
    y: groundY - entitySize,
    vy: 0,
    width: entitySize,
    height: entitySize,
    onGround: true,
    frame: 0,
    frameDelay: 0
  };
  backgroundX = 0;
  obstacles = [];
  gameOver = false;
  gameOverTime = null;
  obstacleTimer = 0;
  lastTimestamp = 0;
}

resetGame();

// Handle jump and restart
document.addEventListener('keydown', e => {
  if (e.code === 'Space') {
    const now = performance.now();

    if (!audioInitialized) {
      initAudio();
    }

    if (gameOver && gameOverTime && now - gameOverTime >= 1000) {
      resetGame();
    } else if (rex.onGround && !gameOver) {
      rex.vy = jumpPower;
      rex.onGround = false;

      // Play alternating jump sounds
      if (jumpSounds.length > 0) {
        jumpSounds[jumpSoundIndex].currentTime = 0;
        jumpSounds[jumpSoundIndex].play();
        jumpSoundIndex = (jumpSoundIndex + 1) % jumpSounds.length;
      }
    }
  }
});

// Initialize audio after user interaction
function initAudio() {
  jumpSounds = [
    new Audio('jump1.mp3'),
    new Audio('jump2.mp3')
  ];
  backgroundMusic = new Audio('background.mp3');
  backgroundMusic.loop = true;
  backgroundMusic.volume = 0.5;
  backgroundMusic.play().catch(err => console.warn('Audio blocked:', err));
  audioInitialized = true;
}

function spawnObstacle() {
  const types = ['obstacle1', 'obstacle2', 'obstacle3', 'obstacle4'];
  const type = types[Math.floor(Math.random() * types.length)];

  let y;

  if (type === 'obstacle4') {
    // Place high in the air at visible jump height
    y = 100; // Adjust this value to control vertical position (lower = higher on screen)
  } else {
    // Ground obstacles
    y = groundY - entitySize;
  }

  obstacles.push({ x: 800, y, width: entitySize, height: entitySize, type });
}
function checkCollision(a, b) {
  const buffer = 0.2;
  const ax = a.x + a.width * buffer;
  const ay = a.y + a.height * buffer;
  const aw = a.width * (1 - 2 * buffer);
  const ah = a.height * (1 - 2 * buffer);
  const bx = b.x + b.width * buffer;
  const by = b.y + b.height * buffer;
  const bw = b.width * (1 - 2 * buffer);
  const bh = b.height * (1 - 2 * buffer);

  return (
    ax < bx + bw &&
    ax + aw > bx &&
    ay < by + bh &&
    ay + ah > by
  );
}

function update(delta) {
  if (gameOver) return;

  rex.vy += gravity;
  rex.y += rex.vy;

  if (!rex.onGround) {
    rex.x += 1.5;
    if (rex.x > 100) rex.x = 100;
  }

  if (rex.y >= groundY - rex.height) {
    rex.y = groundY - rex.height;
    rex.vy = 0;
    rex.onGround = true;
    rex.x = 100;
  }

  backgroundX -= 3;
  if (backgroundX <= -800) backgroundX = 0;

  obstacleTimer += delta;
  if (obstacleTimer > 1500) {
    spawnObstacle();
    obstacleTimer = 0;
  }

  obstacles.forEach(o => o.x -= 5);
  obstacles = obstacles.filter(o => o.x + o.width > 0);

  for (let obs of obstacles) {
    if (checkCollision(rex, obs)) {
      gameOver = true;
      gameOverTime = performance.now();
    }
  }

  rex.frameDelay += delta;
  if (rex.frameDelay > 200) {
    rex.frame = (rex.frame + 1) % 2;
    rex.frameDelay = 0;
  }
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.drawImage(images.bg, backgroundX, -backgroundYOffset, 800, 330);
  ctx.drawImage(images.bg, backgroundX + 800, -backgroundYOffset, 800, 330);

  const rexImg = rex.onGround
    ? (rex.frame === 0 ? images.rex_idle : images.rex_walk1)
    : images.rex_jump;
  ctx.drawImage(rexImg, rex.x, rex.y, rex.width, rex.height);

  obstacles.forEach(o => {
    ctx.drawImage(images[o.type], o.x, o.y, o.width, o.height);
  });

  if (gameOver) {
    ctx.fillStyle = 'red';
    ctx.font = '144px Arial';
    ctx.fillText('לך', 360, 180);
  }
}

function gameLoop(timestamp) {
  const delta = timestamp - lastTimestamp;
  lastTimestamp = timestamp;
  update(delta);
  draw();
  requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);
</script>
</body>
</html>
